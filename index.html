<!DOCTYPE html>
<html>
<head>
    <title>React.js and Flux architecture</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link href="../assets/css/base.css" rel="stylesheet" type="text/css" />
    <style type="text/css">
      .remark-inline-code{
        font-size: 18px;
        color: #333;
        background: #f8f8f8;
      }
    </style>
</head>
<body>
    <header>
        <img class="epam-logo" src="../assets/img/logo.png"/>
        <h1>React.js and Flux architecture</h1>
    </header>

<!-- ================== Slides ================== -->
    <textarea id="source">


class: center, middle

.title[
Front-end training
# React.js and Flux architecture
]

---

# React.js

.img-wrap-70[![MVC-js](assets/img/react-logo.png)]

React.js was released by Facebook. It looks similar in shape but not in size to Angular.js, but it  has a very different philosophy underneath. React has a few key ideas:
- virtual DOM
- component framework
- JavaScript syntax extension (JSX)


Benefits:
- fast rendering
- simple API
- DOM asbstracted away!
---


# How virtual DOM works

//TODO: write how it works
---

# Bootstrapping
React components are widgets that can render themselves and react to user input.
React is bootstraped by rendering root React component into DOM.

Method signature:
```javascript
    ReactComponent render(
		ReactElement element,
		DOMElement container,
		[function callback]
	)
```

Method usage:
```javascript
React.render(<YourRootComponent />, document.getElementById('id1');
```

It's possible to have multiple root nodes.
---

# Component structure

React component API is the most complicated part of React.js.

This is smallest React component:

- using JSX
```javascript
var YourRootComponent = React.createClass(
    render: function() {  
        return <div>Hello world {date={new Date()}}</div> 
    })
```


- without JSX
```javascript
var YourRootComponent = React.createClass(
    render: function() {  
        return React.createElement('li', null, "Hello world" + {date={new Date()})
    })
```

Render method's return value is transformed into virtual and real DOM
---

# React.js data flow
In React.js data is passed from parent components to children using props.

Child components call parents, using passed callbacks.
```javascript
var ItemsList = React.createClass(
    getInitialState: function() {
        return {items: ["item1", "item2", "item3"]
    },
    _handleItemRemove: function(clickedItem) {
        var filteredItems = this.state.items.filter(
             function(item) {return item !== clickedItem}
        )
        this.setState({items: filteredItems}); 
    }
    render: function() {  
        return <Item onRemove={this._handleItemRemove} items={this.state.items} />
    })
}
```
Imagination time!
Imagine React application as a tree of components. Some components have state, and some pass state to their children.

// TODO: draw diagram a la Flux diagram

---


# Component structure in depth

```javascript
var YourRootComponent = React.createClass(
    // Component-specific state
    getInitialState // initial components state
    getDefaultProps // default props values
    propTypes // Strict typed components!

    mixins // Extend component with other components

    // Lifecycle methods
    componentWillMount
    componentDidMount // Opportunity for component's DOM manipulation 
    componentWillReceiveProps  // Opportunity to set component's state
    shouldComponentUpdate  // Opportunity to prevent rendering
    componentWillUpdate
    componentDidUpdate 
    componentWillUnmount // Opportunity to unregister event listeners

    render: function() {  
        return <div>Hello world {date={new Date()}</div>
    }
})
```
---

# Features I like most. #1 - Ease of composability


```javascript
...
    render: function() {
        return (
            <BaseModal
                modalClass={this.props.modalClass}
                closeBtn={true}
                header={this.props.header}
                onClose={this.props.onClose}
                isOpen={this.props.isOpen}
            >
                <form>
                    <div className='input-pair'>
                        <div className='input-pair__title-box'>
                            NAME
                        </div>
                        <div className='input-pair__input-box'>
                            <MacSelect
                                name='country'
                                options={[{value: 'Ukraine', label: 'Ukraine'}, {value: 'USA', label: 'USA'}]}
                                value={this.state.storedParams.country}
                                onChange={this._onInputChange}
                            />
                        </div>
                    </div>
...
```


---
# Features I like most. #2 - No templating language

React Component instances are manipulated using plain old JavaScript
		    
```javascript
...
render: function() {
    return (
        <div className='assets-grid'>
            <div className='assets-grid__items'>
               {this.state.assets.map(function(asset, index) {
                    return <AssetGridItem key={index} asset={asset} />
               })}
            </div>
        </div>
    );
}
...
	
var obj = {
    a: <div>hello</div>,
    b: <ListItem />
};

var listItem = predicate ? <ListItemA /> : <ListItemB />

```

---
# Features I like most. #3 - PropTypes
PropTypes provide strict typing for component's parameters	

```javascript
var YourRootComponent = React.createClass(
    ...
    propTypes: function() {
        return {
           size: React.PropTypes.number,
           position: React.PropTypes.string.isRequired,
           React.PropTypes.oneOf(['News', 'Photos']),
           React.PropTypes.instanceOf(Message)
        }
    }
    ...
)
```

Now YourRootComponent will throw Console warning if initialized without required props or with props of wrong type.
PropTypes also act as a component documentation.
---

#Flux architecture

- CQRS and task based UI
- Motivation
- Implementation
- Interesting practical consequences
	
```javascript
Views ---> (actions) ----> Dispatcher ---> (registered callback) ---> Stores -------+
É…                                                                                   |
|                                                                                   V
+-- (Controller-Views "change" event handlers) ---- (Stores emit "change" events) --+
```
---

# Motivation for Flux architecture
	
	
# CQRS, Flux Stores
CQRS - Command Query Responsibility Segregation. This pattern means using a different models to update and read information. In simple Flux architecture we don't have separate object models, same Model has different interfaces for their command side and their query side.

	
---

# Flux architecture. Task-based UI
Components now nothing about Models. 
They can only trigger methods, which are naming specific 'tasks' in application.

Typical task names:
```javascript
	advancedSearch, loadMoreSearchResults, selectItem, sortItems, fetchItems
```
Code example
```javascript
var AdvancedSearch = React.createClass(
    _handleSearch: function(searchParams) {
       actions.search(searchParams); // actions is object containing all Tasks
    }
    render: function() {  
        return <SearchForm onSubmit={this._handleSearch} />
    })
}
```	

---
	
# Flux architecture. Tasks

Each task as a result triggers Dispatcher event.


# Flux architecture. Dispatcher (central event hub)
View invokes Task, which triggers a Dispatcher events (Actions).

Benefits of passing all Model-mutating events through central Event hub:
- Ease of debugging
- Synchronization of callbacks, what listen same event

---
	
# Flux architecture. Stores.	
This means model mutation occur only after Dispatcher event.
Task based UI prevents direct Models manipulation and provides encapsulation.


Events, to which Model is subscribed act as a Service Layer. A Service Layer defines an application's boundary and its a set of available operations from the perspective of interfacing client layers.

So, if we want to interact with Store - we have to use Service Layer.
	
---

# Example of Store	
```javascript	
module.exports = Fluxxor.createStore({
	initialize: function () {
	    // initial state
        this.allSalesKits = [];
        this.filteredSalesKits = [];
        this.salesKitsFilter = [];

	    // CQRS write interface (subscribe to Dispatcher events)
        this.bindActions(
            constants.GET_SALES_KITS_SUCCESS, this.getSalesKitsSuccess,
            constants.PUSH_SALES_KITS_FILTER, this.pushSalesKitsFilter
        );
    },

    getSalesKitsSuccess: function(kits) {...}, // update allSalesKits & emit('change')
    pushSalesKitsFilter: function(filter) {...}, // update filteredSalesKits & emit('change')

    // CQRS read interface (when 'change' is triggered, components read this state)	
    getState: function () {
        return {
            allSalesKits: this.allSalesKits,
            filteredSalesKits: this.filteredSalesKits
        };
    }
});
```
---
	
#Interesting practical consequences of applying CQRS
- Stores clearly define subset of state they expose
- Modifications of stores occur only after Action

Both these features make develop

---	
    </textarea>
<!-- ================== End of Slides ================== -->

    <script src="../assets/js/remark-latest.min.js" type="text/javascript"></script>
    <script type="text/javascript">remark.create({highlightStyle: 'github'});</script>
</body>
</html>
